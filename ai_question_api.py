"""
AI Question API Integration Layer
Now powered by xAI (Grok) for enhanced question generation
"""

import json
import logging
import os
from datetime import datetime
from typing import Dict, List, Optional
from flask import Blueprint, request, jsonify, session
from flask_login import login_required, current_user

from app import db
from models import Question, CachedQuestion
from xai_question_generator import xai_generator
from subscription_gate import subscription_gate

logger = logging.getLogger(__name__)

ai_question_bp = Blueprint('ai_question', __name__)

# Mixpanel tracking for analytics
def track_question_generation(user_id: int, exam_type: str, topic: str = None, count: int = 1):
    """Track question generation events in Mixpanel"""
    try:
        from subscription_gate import track_mixpanel_event
        
        properties = {
            'exam_type': exam_type,
            'question_count': count,
            'generation_source': 'xai_grok'
        }
        
        if topic:
            properties['topic'] = topic
            
        track_mixpanel_event('Question Generated', user_id, properties)
        logger.info(f"üìä Tracked question generation: user={user_id}, exam={exam_type}, count={count}")
        
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è  Mixpanel tracking failed: {e}")

@ai_question_bp.route('/api/generate-questions', methods=['POST'])
@login_required
@subscription_gate
def generate_questions():
    """Generate new questions using xAI (Grok) with subscription gate"""
    try:
        data = request.get_json()
        exam_type = data.get('exam_type')
        topic = data.get('topic')  # Optional topic specification
        count = min(data.get('count', 5), 10)  # Limit to 10 questions max for xAI
        
        if not exam_type:
            return jsonify({'error': 'Exam type is required'}), 400
            
        # Validate exam type
        valid_exams = [
            'GMAT', 'GRE', 'MCAT', 'USMLE_STEP_1', 'USMLE_STEP_2', 
            'NCLEX', 'LSAT', 'IELTS', 'TOEFL', 'PMP', 'CFA', 'ACT', 'SAT'
        ]
        
        if exam_type not in valid_exams:
            return jsonify({'error': f'Invalid exam type. Must be one of: {valid_exams}'}), 400
        
        # Check if xAI generator is available
        if not xai_generator:
            logger.error("‚ùå xAI generator not initialized")
            return jsonify({'error': 'Question generation service unavailable'}), 503
            
        logger.info(f"üöÄ Generating {count} {exam_type} questions for user {current_user.id}")
        
        # Generate questions using xAI (Grok)
        try:
            questions = xai_generator.generate_questions(
                exam_type=exam_type,
                topic=topic,
                count=count
            )
            
            if not questions:
                logger.error("‚ùå No questions generated by xAI")
                return jsonify({'error': 'Failed to generate questions'}), 500
                
        except Exception as e:
            logger.error(f"‚ùå xAI generation failed: {e}")
            return jsonify({'error': f'Question generation failed: {str(e)}'}), 500
        
        # Track generation in Mixpanel
        track_question_generation(current_user.id, exam_type, topic, len(questions))
        
        # Cache questions for faster future retrieval
        cached_count = 0
        for question_data in questions:
            try:
                cached_question = CachedQuestion(
                    exam_type=exam_type,
                    question_text=question_data['question'],
                    options=json.dumps(question_data['options']),
                    correct_answer=question_data['answer'],
                    explanation=question_data['explanation'],
                    difficulty=question_data.get('difficulty', 'medium'),
                    created_at=datetime.utcnow()
                )
                db.session.add(cached_question)
                cached_count += 1
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è  Failed to cache question: {e}")
        
        try:
            db.session.commit()
            logger.info(f"‚úÖ Cached {cached_count} questions to database")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è  Failed to commit cached questions: {e}")
            db.session.rollback()
        
        # Return questions in OpenAI-compatible format
        response_data = {
            'success': True,
            'questions': questions,
            'count': len(questions),
            'exam_type': exam_type,
            'generated_by': 'xai_grok',
            'timestamp': datetime.utcnow().isoformat()
        }
        
        if topic:
            response_data['topic'] = topic
            
        logger.info(f"‚úÖ Successfully generated {len(questions)} {exam_type} questions")
        return jsonify(response_data)
        
    except Exception as e:
        logger.error(f"‚ùå Error in generate_questions: {str(e)}")
        return jsonify({'error': 'Internal server error'}), 500

@ai_question_bp.route('/api/test-xai-integration', methods=['POST'])
@login_required
def test_xai_integration():
    """Test xAI integration with GRE algebra question"""
    try:
        if not xai_generator:
            return jsonify({'error': 'xAI generator not initialized'}), 503
            
        # Test with requested format: GRE quant algebra
        logger.info("üß™ Testing xAI integration with GRE quant algebra")
        
        questions = xai_generator.generate_questions(
            exam_type="GRE",
            topic="algebra",
            count=1
        )
        
        if not questions:
            return jsonify({'error': 'Test failed - no questions generated'}), 500
            
        question = questions[0]
        
        # Verify OpenAI format compatibility
        required_fields = ['question', 'options', 'answer', 'explanation']
        missing_fields = [field for field in required_fields if field not in question]
        
        if missing_fields:
            return jsonify({
                'error': f'Test failed - missing fields: {missing_fields}',
                'question': question
            }), 500
            
        # Verify options format
        if not isinstance(question['options'], dict) or set(question['options'].keys()) != {'A', 'B', 'C', 'D'}:
            return jsonify({
                'error': 'Test failed - invalid options format',
                'options': question['options']
            }), 500
            
        # Track successful test
        track_question_generation(current_user.id, "GRE", "algebra", 1)
        
        return jsonify({
            'success': True,
            'test_status': 'PASSED',
            'message': 'xAI integration working correctly',
            'sample_question': question,
            'format_validation': 'OpenAI compatible',
            'generated_by': 'xai_grok'
        })
        
    except Exception as e:
        logger.error(f"‚ùå xAI integration test failed: {e}")
        return jsonify({
            'success': False,
            'test_status': 'FAILED', 
            'error': str(e)
        }), 500

# Legacy routes removed - xAI integration complete
# Analytics routes will be updated in future iterations